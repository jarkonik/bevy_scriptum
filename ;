use std::any::TypeId;

use bevy::{
    asset::Asset,
    ecs::{component::Component, entity::Entity},
    reflect::TypePath,
};
use rhai::{CallFnOptions, Dynamic, FuncArgs, Scope};
use serde::Deserialize;

use crate::{
    assets::FileExtension, promise::Promise, systems::CreateScriptData, GetEngine, LuaEngine,
    RegisterRawFn, ScriptData, ScriptingError, ScriptingRuntime, ENTITY_VAR_NAME,
};

/// A rhai language script that can be loaded by the [crate::ScriptingPlugin].
#[derive(Asset, Debug, Deserialize, TypePath, Default)]
pub struct RhaiScript(pub String);

impl From<String> for RhaiScript {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl FileExtension for RhaiScript {
    fn extension() -> &'static [&'static str] {
        &["rhai"]
    }
}

#[derive(Component, Debug)]
pub struct RhaiScriptData {
    pub scope: rhai::Scope<'static>,
    pub(crate) ast: rhai::AST,
}

impl GetEngine<rhai::Engine> for ScriptingRuntime<rhai::Engine> {
    fn engine_mut(&mut self) -> &mut rhai::Engine {
        &mut self.engine
    }
}

impl CreateScriptData<rhai::Engine> for RhaiScript {
    type ScriptData = RhaiScriptData;

    fn create_script_data(
        &self,
        entity: Entity,
        engine: &mut rhai::Engine,
    ) -> Result<Self::ScriptData, ScriptingError> {
        let mut scope = Scope::new();

        scope.push(ENTITY_VAR_NAME, entity);

        let ast = engine
            .compile_with_scope(&scope, &self.0)
            .map_err(ScriptingError::CompileError)?;

        engine
            .run_ast_with_scope(&mut scope, &ast)
            .map_err(ScriptingError::RuntimeError)?;

        scope.remove::<Entity>(ENTITY_VAR_NAME).unwrap();

        Ok(Self::ScriptData { ast, scope })
    }
}

impl RegisterRawFn for ScriptingRuntime<rhai::Engine> {
    fn register_raw_fn<'name, 'types>(
        &mut self,
        name: &'name str,
        arg_types: Vec<TypeId>,
        f: impl Fn() -> Promise + Sync,
    ) {
        self.engine
            .register_raw_fn(name, arg_types, |context, args| {
                let result = f();
                Ok(result)
            });
    }
}

impl ScriptingRuntime<rhai::Engine> {
    /// Get a  mutable reference to the internal [rhai::Engine].

    /// Call a function that is available in the scope of the script.
    pub fn call_fn(
        &mut self,
        function_name: &str,
        script_data: &mut ScriptData<RhaiScriptData>,
        entity: Entity,
        args: impl FuncArgs,
    ) -> Result<(), ScriptingError> {
        let script_data = &mut script_data.data;

        let ast = script_data.ast.clone();
        let scope = &mut script_data.scope;
        scope.push(ENTITY_VAR_NAME, entity);
        let options = CallFnOptions::new().eval_ast(false);
        let result =
            self.engine
                .call_fn_with_options::<Dynamic>(options, scope, &ast, function_name, args);
        scope.remove::<Entity>(ENTITY_VAR_NAME).unwrap();
        if let Err(err) = result {
            match *err {
                rhai::EvalAltResult::ErrorFunctionNotFound(name, _) if name == function_name => {}
                e => Err(Box::new(e))?,
            }
        }
        Ok(())
    }
}
